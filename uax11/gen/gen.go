// Process http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"net/http"
	"unicode"

	"github.com/npillmayer/uax/ucd"
)

var rangeTables map[string]*rangeTable // one for each N, Na, A, …

func main() {
	buf := new(bytes.Buffer)
	rangeTables = makeRangeTables()

	// retrieve unicode character database for UAX#11
	resp, err := http.Get("http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt")
	if err != nil {
		log.Fatal(err)
	}
	printPreamble(buf)

	// parse UCD file and collect ranges
	ucd.Parse(resp.Body, func(p *ucd.Parser) {
		l, r := p.Range(0) // char range in field 0
		t := p.String(1)   // EAW char category as string in field 1
		if t == "" {
			return
		}
		rangeTables[t].append(l, r)
	}, ucd.OptionKeepRanges())

	// output range information per category
	for _, rt := range rangeTables {
		rt.output(buf)
	}
	_, err = format.Source(buf.Bytes())
	if err != nil {
		log.Printf(err.Error())
	}
	err = ioutil.WriteFile("tables.go", buf.Bytes(), 0666)
	if err != nil {
		log.Fatal(err)
	}
}

func printPreamble(buf *bytes.Buffer) {
	fmt.Fprintf(buf, `// Code generated by uax11/gen/gen.go --- DO NOT EDIT.

package uax11

import "unicode"

`)
}

func printRangePreamble(buf *bytes.Buffer, t *rangeTable) {
	fmt.Fprintf(buf, "var _EAW_%s = &unicode.RangeTable{ ", t.cat)
	fmt.Fprintf(buf, "// %d entries", t.cnt)
	fmt.Fprintf(buf, `
	R16: []unicode.Range16{
`)
}

func printRangePostamble(buf *bytes.Buffer, t *rangeTable) {
	if t.latinOffset > 0 {
		fmt.Fprintf(buf, "\t},\n\tLatinOffset: %d,\n}\n\n", t.latinOffset)
	} else {
		fmt.Fprintf(buf, "\t},\n}\n\n")
	}
}

// ---------------------------------------------------------------------------

type rangeTable struct {
	cat              string // East Asian Width char category
	cnt, latinOffset int    // range count and unicode.RangeTable.LatinOffset
	switch32         int    // range item where to switch to int32 size
	ranges           [][2]rune
	lo, hi           rune // low and high bound of current range
}

func (rt *rangeTable) append(l, r rune) {
	if l == rt.hi+1 {
		rt.hi = r // range extends previous range
		return
	}
	// check for switch points in range list
	if rt.latinOffset == 0 && rt.hi > unicode.MaxLatin1 {
		rt.latinOffset = rt.cnt
	}
	if rt.switch32 == 0 && (rt.lo > (1<<16) || rt.hi > (1<<16)) {
		// switch to range32
		rt.switch32 = rt.cnt
	}
	// append current range lo…hi to ranges
	rt.ranges = append(rt.ranges, [2]rune{rt.lo, rt.hi})
	rt.cnt++
	rt.lo, rt.hi = l, r
}

func (rt *rangeTable) output(buf *bytes.Buffer) {
	printRangePreamble(buf, rt)
	for i, r := range rt.ranges {
		if rt.switch32 > 0 && i == rt.switch32 {
			fmt.Fprintf(buf, "\t},\n\tR32: []unicode.Range32{\n")
		}
		fmt.Fprintf(buf, "\t\t{%#04x, %#04x, 1},\n", r[0], r[1])
	}
	printRangePostamble(buf, rt)
}

func makeRangeTables() map[string]*rangeTable {
	r := make(map[string]*rangeTable)
	cats := [...]string{"N", "A", "Na", "W", "H", "F"}
	for _, c := range cats {
		r[c] = &rangeTable{cat: c}
	}
	return r
}
